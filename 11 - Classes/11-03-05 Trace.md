# Trace

Soient la classe suivante et les fonctions

~~~cpp
class Trace {
   friend ostream& operator<< (ostream& os, const Trace& t) {
      return os << t.id << "/" << t.data;
   }

public:
   Trace()           : id(nextId++), data('a')     { cout << "C0(" << *this << ") ";   }
   Trace(char data)  : id(nextId++), data(data)    { cout << "Ci(" << *this << ") ";   }
   Trace(const Trace& other)     :id(nextId++)     { this->data = other.data;
                                                      cout << "CC(" << *this << ") ";   }
   ~Trace()                                        { cout << "D(" << *this << ") ";   }
   Trace& operator=(const Trace& other)            { this->data = other.data;
                                                     cout << "=C("  << other << "->" << *this << ") ";
                                                     return *this; }
private:
   static char nextId;
   int  id;
   char data;
};

char Trace::nextId = 1;

Trace f1(char i)         { cout << "f1 : "; return Trace(i); }
Trace f2(Trace t)        { cout << "f2 : "; return t;        }
Trace f3(const Trace& t) { cout << "f3 : "; return t;        }
~~~

Que produisent les déclarations ou instructions suivantes ?

<br>

~~~cpp
// no 1
Trace trace1a;
~~~

<details>
<summary>Solution</summary>

~~~
C0(1/a)
~~~

------------------------------------------------------------

</details>

~~~cpp
// no 2
Trace trace1b('a');
~~~

<details>
<summary>Solution</summary>

~~~
Ci(2/a)
~~~

------------------------------------------------------------

</details>

~~~cpp
// no 3
Trace trace1c(trace1a);
~~~

<details>
<summary>Solution</summary>

~~~
CC(3/a)
~~~

------------------------------------------------------------

</details>

~~~cpp
// no 4
Trace trace1d(Trace('b'));
~~~

<details>
<summary>Solution</summary>

~~~
Ci(4/b)
~~~

------------------------------------------------------------

</details>

~~~cpp
// no 5
Trace trace1e(f1('c'));
~~~

<details>
<summary>Solution</summary>

~~~
f1 : Ci(5/c)
~~~

------------------------------------------------------------

</details>

~~~cpp
// no 6
Trace trace1f(f2(trace1a));
~~~

<details>
<summary>Solution</summary>

~~~
CC(6/a) f2 : CC(7/a) D(6/a)
~~~

- passage de `trace1a` par valeur (copie) à `f2` => `CC(6/a)`
- utilisation du retour de `f2` pour contructruire `trace1f` => `CC(7/a)`
- fin de `f2` et destruction du paramètre => `D(6/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 7
Trace trace1g(f3(trace1a));
~~~

<details>
<summary>Solution</summary>

~~~
f3 : CC(8/a)
~~~

- le parmètre `trace1a` est directement utilisé pour construire `trace1g` => `CC(8/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 8
vector<Trace> vect(3, Trace('b'));
~~~

<details>
<summary>Solution</summary>

~~~
Ci(9/b) CC(10/b) CC(11/b) CC(12/b) D(9/b)
~~~

- création de `Trace(2)` => `Ci(9/b)`
- 3 copies dans le vecteur => `CC(10/b) CC(11/b) CC(12/b)`
- suppression de l'objet temporaire => `Ci(9/b)`

Note

~~~
vect.size()     => 3
vect.capacity() => 3
~~~

------------------------------------------------------------

</details>

~~~cpp
// no 9
vect.push_back(trace1a);
~~~

<details>
<summary>Solution</summary>

~~~
CC(13/a) CC(14/b) CC(15/b) CC(16/b) D(12/b) D(11/b) D(10/b)
~~~

- mise à jour de la capacité (3 => 6) et de la taille (3 => 4) du vecteur 
- construction par copie du nouvelle élément => `CC(13/a)`
- construction par copie des éléments dans le nouvel emplacement mémoire => `CC(14/b) CC(15/b) CC(16/b)`
- suppression des éléments dans l'ancien emplacement mémoire => `D(12/b) D(11/b) D(10/b)`

------------------------------------------------------------

</details>

~~~cpp
// no 10
Trace trace2a('b');
trace2a = trace1a;
~~~

<details>
<summary>Solution</summary>

~~~
Ci(17/b) =C(1/a->17/a)
~~~

- construction de `trace2a(2)` => `Ci(17/b)`
- affectation dans `trace2a` => `=C(1/a->17/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 11
trace2a = f1('c');
~~~

<details>
<summary>Solution</summary>

~~~
f1 : Ci(18/c) =C(18/c->17/c) D(18/c)
~~~

- appel de `f1` avec `3` comme paramètre
- construction dans la fonction de l'objet => `Ci(18/c)`
- affection dans `trace2a` du retour de `f1` => `=C(18/c->17/c)`
- desctruction de l'objet au terme de la fonction => `D(18/c)`

------------------------------------------------------------

</details>

~~~cpp
// no 12
trace2a = f2(trace1a);
~~~

<details>
<summary>Solution</summary>

~~~
CC(19/a) f2 : CC(20/a) =C(20/a->17/a) D(20/a) D(19/a)
~~~

- appel de `f2` et passage par valeur (copie) de `trace1a` => `CC(19/a)`
- retour du paramètre `t` à `Trace` => `CC(20/a)`
- affectation dans `trace2a` => `=C(20/a->17/a)`
- suppression du paramètre et de l'objet utilisé pour le retour => `D(20/a) D(19/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 13
trace2a = f3(trace1a);
~~~

<details>
<summary>Solution</summary>

~~~
f3 : CC(21/a) =C(21/a->17/a) D(21/a)
~~~

- passage du paramètre par ref constante `const Trace& t`
- retour du paramètre `t` à `Trace` => `CC(21/a)`
- affectation dans `trace2a` => `=C(21/a->17/a)`
- suppression de l'objet utilisé pour le retour => `D(21/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 14
{
   Trace trace1b('a');
}
~~~

<details>
<summary>Solution</summary>

~~~
Ci(22/a) D(22/a)
~~~

- construction avec `trace1b(1)` => `Ci(22/a)`
- sortie du bloc `{..}`, donc destruction de l'objet => `D(22/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 15
{
   vector<Trace> v(3);
}
~~~

<details>
<summary>Solution</summary>

~~~
C0(23/a) C0(24/a) C0(25/a) D(25/a) D(24/a) D(23/a)
~~~

- construction de 3 objets pour le vecteur => `C0(23/a) C0(24/a) C0(25/a)`
- sortie du bloc `{..}`, donc destruction des 3 objets => `D(25/a) D(24/a) D(23/a)`

------------------------------------------------------------

</details>

~~~cpp
// no 16
{
   vector<Trace> v(2, Trace('a'));
}
~~~

<details>
<summary>Solution</summary>

~~~
Ci(26/a) CC(27/a) CC(28/a) D(26/a) D(28/a) D(27/a)
~~~

- construction de 1 objet connu `Ci(26/a)`
- ... copie de cet objets dans les autres éléments du vecteur => `CC(27/a) CC(28/a)`
- sortie du bloc `{..}`, donc destruction des 3 objets => `D(26/a) D(28/a) D(27/a)`


------------------------------------------------------------

</details>

~~~cpp
// no 17
{
   vector<Trace> v(2, trace1a);
}
~~~

<details>
<summary>Solution</summary>

~~~
CC(29/a) CC(30/a) D(30/a) D(29/a)
~~~

- copie de `trace1a` dans les éléments du vecteur => `CC(29/a) CC(30/a)`
- sortie du bloc `{..}`, donc destruction des 3 objets => `D(30/a) D(29/a)`

------------------------------------------------------------

</details>

------------------------------------------------------------
<details>
<summary>code complet</summary>

~~~cpp
#include <iostream>
#include <vector>

using namespace std;

class Trace {
   friend ostream& operator<< (ostream& os, const Trace& t) {
      return os << t.id << "/" << t.data;
   }

public:
   Trace()           : id(nextId++), data('a')     { cout << "C0(" << *this << ") ";   }
   Trace(char data)  : id(nextId++), data(data)    { cout << "Ci(" << *this << ") ";   }
   Trace(const Trace& other)     :id(nextId++)     { this->data = other.data;
                                                      cout << "CC(" << *this << ") ";   }
   ~Trace()                                        { cout << "D(" << *this << ") ";   }
   Trace& operator=(const Trace& other)            { this->data = other.data;
                                                     cout << "=C("  << other << "->" << *this << ") ";
                                                     return *this; }
private:
   static char nextId;
   int  id;
   char data;
};

char Trace::nextId = 1;

Trace f1(char i)         { cout << "f1 : "; return Trace(i); }
Trace f2(Trace t)        { cout << "f2 : "; return t;        }
Trace f3(const Trace& t) { cout << "f3 : "; return t;        }

int main() {

   // no 1
   cout << "no  1 : ";
   Trace trace1a;
   cout << endl;

   // no 2
   cout << "no  2 : ";
   Trace trace1b('a');
   cout << endl;

   // no 3
   cout << "no  3 : ";
   Trace trace1c(trace1a);
   cout << endl;

   // no 4
   cout << "no  4 : ";
   Trace trace1d(Trace('b'));
   cout << endl;

   // no 5
   cout << "no  5 : ";
   Trace trace1e(f1('c'));
   cout << endl;

   // no 6
   cout << "no  6 : ";
   Trace trace1f(f2(trace1a));
   cout << endl;

   // no 7
   cout << "no  7 : ";
   Trace trace1g(f3(trace1a));
   cout << endl;

   // no 8
   cout << "no  8 : ";
   vector<Trace> vect(3, Trace('b'));
   cout << endl;
   cout << vect.size() << " / " << vect.capacity();
   cout << endl;

   // no 9
   cout << "no  9 : ";
   vect.push_back(trace1a);
   cout << endl;
   cout << vect.size() << " / " << vect.capacity();
   cout << endl;

   // no 10
   cout << "no 10 : ";
   Trace trace2a('b');
   trace2a = trace1a;
   cout << endl;

   // no 11
   cout << "no 11 : ";
   trace2a = f1('c');
   cout << endl;

   // no 12
   cout << "no 12 : ";
   trace2a = f2(trace1a);
   cout << endl;

   // no 13
   cout << "no 13 : ";
   trace2a = f3(trace1a);
   cout << endl;

   // no 14
   cout << "no 14 : ";
   {
      Trace trace1b('a');
   }
   cout << endl;

   // no 15
   cout << "no 15 : ";
   {
      vector<Trace> v(3);
   }
   cout << endl;

   // no 16
   cout << "no 16 : ";
   {
      vector<Trace> v(2, Trace('a'));
   }
   cout << endl;

   // no 17
   cout << "no 17 : ";
   {
      vector<Trace> v(2, trace1a);
   }
   cout << endl;

   cout << "fin de programme" << endl;
}
~~~

~~~
no  1 : C0(1/a) 
no  2 : Ci(2/a) 
no  3 : CC(3/a) 
no  4 : Ci(4/b) 
no  5 : f1 : Ci(5/c) 
no  6 : CC(6/a) f2 : CC(7/a) D(6/a) 
no  7 : f3 : CC(8/a) 
no  8 : Ci(9/b) CC(10/b) CC(11/b) CC(12/b) D(9/b) 
3 / 3
no  9 : CC(13/a) CC(14/b) CC(15/b) CC(16/b) D(12/b) D(11/b) D(10/b) 
4 / 6
no 10 : Ci(17/b) =C(1/a->17/a) 
no 11 : f1 : Ci(18/c) =C(18/c->17/c) D(18/c) 
no 12 : CC(19/a) f2 : CC(20/a) =C(20/a->17/a) D(20/a) D(19/a) 
no 13 : f3 : CC(21/a) =C(21/a->17/a) D(21/a) 
no 14 : Ci(22/a) D(22/a) 
no 15 : C0(23/a) C0(24/a) C0(25/a) D(25/a) D(24/a) D(23/a) 
no 16 : Ci(26/a) CC(27/a) CC(28/a) D(26/a) D(28/a) D(27/a) 
no 17 : CC(29/a) CC(30/a) D(30/a) D(29/a) 
fin de programme
D(17/a) D(13/a) D(14/b) D(15/b) D(16/b) D(8/a) D(7/a) D(5/c) D(4/b) D(3/a) D(2/a) D(1/a) 
~~~

</details>

